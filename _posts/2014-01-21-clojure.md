---
layout: post
title: Clojure vs. C++ (My Personal Difficulties)
category: article
comments: true
tags: [programming, clojure, c++]
---

### Using Clojure
Recently I've gotten into programming Clojure, which in general has been an
excellent experience. The community is solid, there's plenty of good
documentation about the langauge and (in general) it's a pleasure to write code
in Clojure. It's sort of a stark transition from the curly-brace languages, but
a mentally stimulating one, and the abstractions that Clojure provides make
certain problems *much* easier to deal with. As part of my transition to the
Clojure mindset, I've been trying to implement some algorithms in Clojure that
I've implemented many times in other languages, and have found that certain
things, like the sequence abstraction make programming a joy.

### C++ vs. Clojure
One useful function from the realm of mathematics is the generalized Euclidian
Distance function. It takes two n-dimensional points and calculates the distance
as would be measured by a ruler (read: straight line) between
them. ![Euclidian Distance Formula](http://upload.wikimedia.org/math/3/e/3/3e31af0e62dd2780540f796b51a0ce4e.png)

A naive solution in C++ would be the following:
{% highlight cpp %}
double euc_distance(Point p, Point q) {
    int dimension = q.size();
    double distance
    vector<double> components;
    double sum_of_squares = 0;

    for (int i = 0; i < dimension; i++)
        components.push_back(q.coor()[i] - p.coor()[i]);
    for (auto it = components.begin(); it != components.end(); ++it)
        sum_of_squares += pow(*it, 2);

    distance = pow(sum_of_squares, (1.0/2));
    return distance;
}
{% endhighlight %}
This solution assumes that both points will be of the same dimensionality. I'm sure
there's a simpler way to do this in C++, but without thinking very hard, this is
a reasonable solution. Each corresponding component is subtracted, and then each
of those results is squared and added together, finally the square root is
taken.

Here is a Clojure Solution:
{% highlight clj %}
(defn euc-distance
    [x y]
    {:pre (= (count x) (count y))}
    (pow (apply + (map #(* % %) (map - x y)))
        1/2))
{% endhighlight %}
Wow! The Clojure version even makes sure that the two points given to it are
the same dimensionality! I think it's a little more difficult to read, (you could
probably fix this up with one of the thrushing macros) but it
still makes perfect sense and avoids somewhat ugly things like for loops. It sort of
forces you to think from the outside-in. If you were to read this, it
would sound like this: "take the square root of the sum of the squared,
component-wise subracted points". Which, if you check against the formula above,
will get you the right answer.

### Why Does It Matter?
There's a trend recently of "X Language is Better than Y Language because
factorial looks like this in X Language" type posts, but this one will attempt
to not be like that, because I don't see much value in that. The way your chosen
langauge shapes the way you have to think about a problem is interesting though,
and being able to represent and think about a problem from different
perspectives is vital to being a good programmer. Clojure will likely never beat
C++ in terms of efficiency, and C++ will (by design) never have the same
syntactical abstraction capabilities of Clojure and other lisps. Design choices
typically affect what kinds of problems are easy in a given language, but there
will always be problems that are hard despite design changes to mitigate things.
